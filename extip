#!/usr/bin/env perl

use IO::Socket::INET;
use IO::Socket::SSL;
use IO::Select;
use Data::Dumper;
use threads 'exit'=>'threads_only';
use warnings;
use Getopt::Long;
use Time::HiRes 'gettimeofday';
use feature 'switch';
use Net::DNS;


$Timeout = 2.5;
$details = 0;
$quiet_http = 0;
$Selector = IO::Select->new();

@URL = qw{
 myexternalip.com/raw
 curlmyip.com
 ident.me
 https://tnx.nl/ip
 ipecho.net/plain
 whatismyip.akamai.com
 wtfismyip.com/text
 bot.whatismyipaddress.com
 wgetip.com
 ip.tyk.nu
 ifconfig.me/ip
 icanhazip.com
 corz.org/ip
 ipinfo.io/ip
 https://simplesniff.com/ip
 ip.42.pl/raw
 dns@ns1.google.com:o-o.myaddr.l.google.com/TXT
 dns@ns1-1.akamaitech.net:whoami.akamai.net/A
 https://1.1.1.1/cdn-cgi/trace|cloudflare_trace
};



sub mainthread
{
	my ($schema, $host, $port, $path, $filter, $writer) = @_;
	my $self = threads->self();
	my $socket;
	my $module;
	
	given($schema)
	{
		when('http')
		{
			$module = IO::Socket::INET;
		}
		when('https')
		{
			$module = IO::Socket::SSL;
		}
	}
	
	given($schema)
	{
		when(/^https?$/)
		{
			my (undef, undef, $port, undef) = getservbyname $schema, 'tcp' if not defined $port;
	 		$socket = $module->new($host . ':' . $port);
	 		if(not defined $socket)
	 		{
	 			printf {$writer} "%d 0 0 $!\n", $self->tid;
	 			close $writer;
	 			return;
	 		}
	 		print {$socket} join "\r\n",
	 			"GET $path HTTP/1.0",
	 			"Host: $host",
	 			"Accept: */*",
	 			"", "";
	 		
	 		my $status;
	 		my $eoh;
	 		my $result;
	 		
	 		while(my $ln = <$socket>)
	 		{
	 			$ln =~ s/\s*$//;
	 				
	 			if(not defined $status)
	 			{
	 				($status->{code}, $status->{msg}) = ($ln =~ /^\S+\s+(\S+)\s*(.*)$/);
	 			}
	 			
	 			if($status->{code} eq '200')
	 			{
	 				if($eoh)
	 				{
	 					$result = $ln;
	 					printf {$writer} "%d 1 %s\n", $self->tid, $result;
	 					last;
	 				}
	 				elsif($ln =~ /^[\r\n]*$/)
	 				{
	 					$eoh = 1;
	 				}
	 			}
	 			else
	 			{
	 				printf {$writer} "%d 0 %s %s\n", $self->tid, $status->{code}, $status->{msg};
	 				last;
	 			}
	 		}
	 	}
	 	when(/^dns(\@|$)/)
	 	{
	 		my ($nameserver) = ($schema =~ /\@(.+)/);
	 		my ($record_type) = ($path =~ /^\/(.+)/);
	 		
	 		my $dns = Net::DNS::Resolver->new;
	 		$dns->nameservers($nameserver) if defined $nameserver;
	 		my $reply = $dns->query($host, $record_type);
	 		if($reply)
	 		{
	 			my $n = 0;
	 			for my $rr ($reply->answer)
	 			{
	 				my $result;
	 				given($record_type)
	 				{
	 					when('TXT') { $result = $rr->{'rdata'}; }
			 			default { $result = $rr->{'address'}; }
			 		}
			 		if(defined $result)
			 		{
		 				printf {$writer} "%d 1 %s\n", $self->tid, $result;
		 				$n++;
		 			}
	 			}
	 			if($n == 0)
	 			{
		 			printf {$writer} "%d 0 only records found: %s\n", $self->tid, join "; ", map {sprintf "%s %s %s %s", $_->name, $_->class, $_->type, strrepl($_->rdata,"\n","\\n")} $reply->answer;
	 			}
	 		}
	 		else
	 		{
	 			printf {$writer} "%d 0 %s\n", $self->tid, $dns->errorstring;
	 		}
	 	}
	}
	
	close $writer;
}

sub strrepl
{
	my ($str, $patt, $repl) = @_;
	$str =~ s/\Q$patt\E/$repl/g;
	return $str;
}


GetOptions(
	'T|timeout=f' => \$Timeout,
	'd|details!' => \$details,
	'q|quiet!' => \$quiet_http,
	'u|url=s{1,}' => \@UserURL,
	'A|add-url=s{1,}' => sub {
		unshift @URL, $_[1];
	},
	'R|remove-url=s{1,}' => sub {
		@URL = grep {$_ ne $_[1]} @URL;
	},
	'h|help' => sub {
		print "Options:
 -T, --timeout FLOAT     Overall timeout waiting for responses ($Timeout)
 -d, --details           Display each service's response (off)
 -q, --quiet             Suppress HTTP errors (off)
 -u, --url URL URL ...   Define extip services (@URL)
 -A, --add-url URL ...   Add extip services to the base set
 -R, --remove-url URL ...    Remove extip services from the base set
";
		exit 0;
	},
) or die;

if(@UserURL)
{
	@URL = @UserURL;
}

for my $url (@URL)
{
	my ($schema, $host, $port, $path, $filter) = ($url =~ m{^(?:([^:/]+):(?://)?)?([^:/]+)(?::(\d+))?(.*?)(?:\|(.+))?$});
	$schema ||= 'http';
	$path ||= '/';
	my $rdr;
	my $wtr;
	pipe $rdr, $wtr;
	my $thr = threads->create(\&mainthread, $schema, $host, $port, $path, $filter, $wtr);
	push @SRC, {url=>$url, thr=>$thr, reader=>$rdr};
}

for my $src (@SRC)
{
	$Selector->add($src->{reader});
}



$t0 = gettimeofday;
while(my @ready = $Selector->can_read($Timeout))
{
	$Timeout -= (gettimeofday - $t0);
	$t0 = gettimeofday;
	
	for my $fhnd (@ready)
	{
		if(eof($fhnd))
		{
			$Selector->remove($fhnd);
		}
		else
		{
			my ($tid, $ok, $result) = split /\s+/, <$fhnd>, 3;
			$result =~ s/\s*$//;
			
			for my $src (@SRC)
			{
				if($src->{reader} eq $fhnd)
				{
					if($ok)
					{
						$Result{$result}++;
						if($details)
						{
							printf "%s\t%s\n", $src->{url}, $result;
						}
					}
					else
					{
						if(!$quiet_http)
						{
							printf STDERR "%s\t%s\n", $src->{url}, $result;
						}
					}
					last;
				}
			}
		}
	}
}


for my $src (@SRC)
{
	$src->{thr}->detach;
}


if(%Result)
{
	# display that result which is returned by the most thread
	print((sort {$Result{$b} <=> $Result{$a}} keys %Result)[0], "\n");
}
else
{
	exit 1;
}
