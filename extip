#!/usr/bin/env perl

use IO::Socket::INET;
use IO::Socket::SSL;
use IO::Select;
use Data::Dumper;
use threads 'exit'=>'threads_only';
use warnings;
use Getopt::Long;
use Time::HiRes 'gettimeofday';
use feature 'switch';


$Timeout = 2.5;
$details = 0;
$quiet_http = 0;
$Selector = IO::Select->new();

@URL = qw{
 myexternalip.com/raw
 curlmyip.com
 ident.me
 https://tnx.nl/ip
 ipecho.net/plain
 whatismyip.akamai.com
 wtfismyip.com/text
 ipof.in/txt
 bot.whatismyipaddress.com
 wgetip.com
 ip.tyk.nu
 ifconfig.me/ip
 icanhazip.com
 corz.org/ip
 ipinfo.io/ip
 https://simplesniff.com/ip
 api.ipify.org?format=text
};



sub mainthread
{
	my ($schema, $host, $port, $path, $writer) = @_;
	my $self = threads->self();
	my $socket;
	my $module;

	if(not defined $port)
	{
		(undef, undef, $port, undef) = getservbyname $schema, 'tcp';
	}
	
	given($schema)
	{
		when('http')
		{
			$module = IO::Socket::INET;
		}
		when('https')
		{
			$module = IO::Socket::SSL;
		}
	}
	$socket = $module->new($host . ':' . $port);
	if(not defined $socket)
	{
		printf {$writer} "%d 0 0 $!\n", $self->tid;
		close $writer;
		return;
	}
	print {$socket} join "\r\n",
		"GET $path HTTP/1.0",
		"Host: $host",
		"Accept: */*",
		"", "";

	my $status;
	my $eoh;
	my $result;
	
	while(my $ln = <$socket>)
	{
		$ln =~ s/\s*$//;
			
		if(not defined $status)
		{
			($status->{code}, $status->{msg}) = ($ln =~ /^\S+\s+(\S+)\s*(.*)$/);
		}
		
		if($status->{code} eq '200')
		{
			if($eoh)
			{
				$result = $ln;
				printf {$writer} "%d 1 %s\n", $self->tid, $result;
				last;
			}
			elsif($ln =~ /^[\r\n]*$/)
			{
				$eoh = 1;
			}
		}
		else
		{
			printf {$writer} "%d 0 %s %s\n", $self->tid, $status->{code}, $status->{msg};
			last;
		}
	}
	close $writer;
}


GetOptions(
	'T|timeout=f' => \$Timeout,
	'd|details!' => \$details,
	'q|quiet!' => \$quiet_http,
	'u|url=s{1,}' => \@UserURL,
	'A|add-url=s{1,}' => sub {
		unshift @URL, $_[1];
	},
	'R|remove-url=s{1,}' => sub {
		@URL = grep {$_ ne $_[1]} @URL;
	},
	'h|help' => sub {
		print "Options:
 -T, --timeout FLOAT     Overall timeout waiting for responses ($Timeout)
 -d, --details           Display each service's response (off)
 -q, --quiet             Suppress HTTP errors (off)
 -u, --url URL URL ...   Define extip services (@URL)
 -A, --add-url URL ...   Add extip services to the base set
 -R, --remove-url URL ...    Remove extip services from the base set
";
		exit 0;
	},
) or die;

if(@UserURL)
{
	@URL = @UserURL;
}

for my $url (@URL)
{
	my ($schema, $host, $port, $path) = ($url =~ m{^(?:([^:/]+)://)?([^:/]+)(?::(\d+))?(.*)$});
	$schema ||= 'http';
	$path ||= '/';
	my $rdr;
	my $wtr;
	pipe $rdr, $wtr;
	my $thr = threads->create(\&mainthread, $schema, $host, $port, $path, $wtr);
	push @SRC, {url=>$url, thr=>$thr, reader=>$rdr};
}

for my $src (@SRC)
{
	$Selector->add($src->{reader});
}



$t0 = gettimeofday;
while(my @ready = $Selector->can_read($Timeout))
{
	$Timeout -= (gettimeofday - $t0);
	$t0 = gettimeofday;
	
	for my $fhnd (@ready)
	{
		if(eof($fhnd))
		{
			$Selector->remove($fhnd);
		}
		else
		{
			my ($tid, $ok, $result) = split /\s+/, <$fhnd>, 3;
			$result =~ s/\s*$//;
			
			for my $src (@SRC)
			{
				if($src->{reader} eq $fhnd)
				{
					if($ok)
					{
						$Result{$result}++;
						if($details)
						{
							printf "%s\t%s\n", $src->{url}, $result;
						}
					}
					else
					{
						if(!$quiet_http)
						{
							printf STDERR "%s\t%s\n", $src->{url}, $result;
						}
					}
					last;
				}
			}
		}
	}
}


for my $src (@SRC)
{
	$src->{thr}->detach;
}


if(%Result)
{
	print((sort {$Result{$b} <=> $Result{$a}} keys %Result)[0], "\n");
}
else
{
	exit 1;
}

